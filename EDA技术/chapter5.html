<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>EDA技术 第5章</title>

	<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
	<meta name="author" content="ldc">

	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<link rel="stylesheet" href="js/reveal.js-3.7.0/css/reveal.css">
	<link rel="stylesheet" href="js/reveal.js-3.7.0/css/theme/sky.css" id="theme">

	<script type="text/javascript" src="js/SyntaxHighlighter/scripts/shCore.js"></script>
	<script type="text/javascript" src="js/SyntaxHighlighter/scripts/shBrushVHDL.js"></script>
	<link type="text/css" rel="stylesheet" href="js/SyntaxHighlighter/styles/shCoreDefault.css"/>
	<link type="text/css" rel="stylesheet" href="js/SyntaxHighlighter/styles/shThemeDefault.css"/>
	<script type="text/javascript">SyntaxHighlighter.all();</script>

	<link rel="stylesheet" href="css/style3.css">
	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'js/reveal.js-3.7.0/css/print/pdf.css' : 'js/reveal.js-3.7.0/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
			
		var ldc;
	</script>

	<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	<script type="text/x-mathjax-config">
	  MathJax.Hub.Config({
		extensions: ["tex2jax.js"],
		jax: ["input/TeX","output/HTML-CSS"],
		tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}
	  });
	</script>
	<script src="js/mathjax/MathJax.js"></script>
	<script src="js/three/three.js"></script>
	<script src="js/three/examples/js/controls/OrbitControls.js"></script>
</head>

<body>

	<div class="reveal">

		<!-- Any section element inside of this container is displayed as a slide -->
		<div class="slides">
			<section>
				<section>
					<h1>第五章</h1>
					<h2>时序电路的VHDL设计</h2>
				</section>
				
				<section>
					<h2>主要内容</h2>
					<ol>
						<li class="fragment fade-left">基本时序元件及其VHDL描述</li>
						<li class="fragment fade-left">计数器及其VHDL描述</li>
						<li class="fragment fade-left">移位寄存器及其VHDL描述</li>
						<li class="fragment fade-left">属性描述与定义</li>
					</ol>
				</section>
			</section>
			
			<section>
				<section>
					<h2>5.1 基本时序元件及其VHDL描述</h2>
					<p>基本时序元件包括：触发器，锁存器。</p>
				</section>
				
				<section>
					<h3>5.1.1 D触发器</h3>
					<div class="flex">
						<img src="images/dff1.png" />
						<img src="images/dff1_wave.png" />
					</div>
					<p>d触发器当时钟信号clk上升沿到来时，输出口q的值随输入口d的值而变化。</p>
				</section>
				
				<section>
					<h3>5.1.1 D触发器</h3>
					<div class="flex">
						<script type="syntaxhighlighter" class="brush:vhdl;highlight:[13];"> 
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;

ENTITY dff1 IS
PORT(clk, d: IN std_logic; 
	       q: OUT std_logic );
END ENTITY dff1;

ARCHITECTURE bhv OF dff1 IS
signal q1 : std_logic;
begin
	process (clk, q1) begin
		if clk'event and clk='1' then
			q1 <= d;
		end if;
	end process;
	q <= q1;
end architecture bhv;
						</script>
						<div>
						<p>1. 上升沿检测和信号属性函数<code>event</code></p>
						<p class="fragment fade-left red"><code>event</code>是信号属性函数，在<code>IEEE.STD_LOGIC_1164</code>程序包中声明，用来获取信号的行为信息。</p>
						<p class="fragment fade-left blue">VHDL通过：<code>信号名'event</code> 来测定指定信号的跳变情况；</p>
						<p class="fragment fade-left green">当clk在9个可能取值中跳到另一个时，这个表达式的值为<code>TRUE</code>，否则为<code>FALSE</code>;</p>
						</div>
					</div>
					<p class="fragment fade-left red">第13行，当clk跳变，且最终='1'时，其结果为真，这即上升沿测试。</p>					
				</section>
				
				<section>
					<h3>5.1.1 D触发器</h3>
					<div class="flex">
						<script type="syntaxhighlighter" class="brush:vhdl;highlight:[13,14,15];"> 
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;

ENTITY dff1 IS
PORT(clk, d: IN std_logic; 
	       q: OUT std_logic );
END ENTITY dff1;

ARCHITECTURE bhv OF dff1 IS
signal q1 : std_logic;
begin
	process (clk, q1) begin
		if clk'event and clk='1' then
			q1 <= d;
		end if;
	end process;
	q <= q1;
end architecture bhv;
						</script>
						<div>
						<p>2. 不完整条件语句和时序电路</p>
						<p class="fragment fade-left Navy">第13-15行，当信号clk发生跳变，但是不是上升沿的时候，程序并没有处理，vhdl理解为需要存储q1的状态，于是加入了一个锁存器，成为时序电路；</p>
						</div>
					</div>
				</section>
				
				<section>
					<h3>5.1.2 含异步复位和时钟使能的D触发器</h3>
					<div class="flex">
						<img src="images/dff2.png" />
						<img src="images/dff2_wave.png" />
					</div>
					<p>新加两个控制口，rst任何时候设为'1'则强制输出为'0'，而en端则只在时钟上升沿的时候有效。</p>
				</section>
				
				<section>
					<h3>5.1.2 含异步复位和时钟使能的D触发器</h3>
					<div class="flex">
						<script type="syntaxhighlighter" class="brush:vhdl;highlight:[13,15,16];"> 
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;

ENTITY dff2 IS
PORT(clk, rst, en, d: IN std_logic; 
	       q: OUT std_logic );
END ENTITY dff2;

ARCHITECTURE bhv OF dff2 IS
signal q1 : std_logic;
begin
	process (clk, q1, rst, en) begin
		if rst='1' then 
			q1<='0';
		elsif clk'event and clk='1' then
			if en='1' then
				q1 <= d;
			end if;
		end if;
	end process;
	q <= q1;
end architecture bhv;		</script>
						<div>
						<p>注意：</p>
						<p class="fragment fade-left Navy">凡是独立于时钟的异步控制信号都放在时钟边沿检测的上面。</p>
						<p class="fragment fade-left green">凡是依赖于时钟的控制信号都放在时钟边沿检测的下面。</p>
						</div>
					</div>
				</section>
				
				<section>
					<h3>5.1.3 基本锁存器</h3>
					<div class="flex">
						<script type="syntaxhighlighter" class="brush:vhdl;highlight:[11,12];"> 
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;

ENTITY ltch2 IS
PORT(clk, d: IN std_logic; 
	       q: OUT std_logic );
END ENTITY ltch2;

ARCHITECTURE bhv OF ltch2 IS
begin
	process (clk, d) begin
		if clk='1' then
			q<=d;
		end if;
	end process;
end architecture bhv;		</script>
						<div>
						<p>注意：</p>
						<p class="fragment fade-left Navy">本例没有采用时钟边沿检测；</p>
						<p class="fragment fade-left green">注意，在时钟固定，d变化时也会被触发；</p>
						</div>
					</div>
				</section>
				
				<section>
					<h3>5.1.4 含有置零控制的锁存器</h3>

						<script type="syntaxhighlighter" class="brush:vhdl;highlight:[11,12,14];"> 
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;

ENTITY ltch3 IS
PORT(clk, d, rst: IN std_logic; 
	       q: OUT std_logic );
END ENTITY ltch3;

ARCHITECTURE bhv OF ltch3 IS
begin
	process (clk, d, rst) begin
		if rst='1' then
			q<='0';
		elsif clk='1' then
			q<=d;
		end if;
	end process;
end architecture bhv;		</script>

				</section>
				
				<section>
					<h3>5.1.5 时序电路的不同表述</h3>
					<p>检测上升沿，除了前面的以外，可以用下面几种方法：</p>
<script type="syntaxhighlighter" class="brush:vhdl;"> 
if clk'event and (clk='1') and (clk'last_value='0') then ...</script>
<script type="syntaxhighlighter" class="brush:vhdl;"> 
if (clk'event and clk='1') and (clk'last_value='0') then ...</script>
<script type="syntaxhighlighter" class="brush:vhdl;"> 
if rising_edge(clk) then --需要用到IEEE.STD_LOGIC_1164</script>
<p>检测下降沿，除了前面的以外，可以用下面几种方法：</p>
<script type="syntaxhighlighter" class="brush:vhdl;"> 
if clk'event and (clk='0') and (clk'last_value='1') then ...</script>
<script type="syntaxhighlighter" class="brush:vhdl;"> 
if (clk'event and clk='0') and (clk'last_value='1') then ...</script>
<script type="syntaxhighlighter" class="brush:vhdl;"> 
if falling_edge(clk) then --需要用到IEEE.STD_LOGIC_1164</script>
				</section>
				
								<section>
					<h3>5.1.5 时序电路的不同表述</h3>
					<p>检测上升沿，还可以使用<code>wait</code>语句, vhdl规定，若果<code>process</code>里有<code>wait</code>，则可以没有敏感信号表：</p>
<script type="syntaxhighlighter" class="brush:vhdl;"> 
wreg: process begin
	wait until clk='1';
	q <= d;
end process;</script>
<p>或者用下面的并行语句：</p>
<script type="syntaxhighlighter" class="brush:vhdl;"> 
wreg: block(clk'event and clk='1') 
begin
	q <= guarded d;
end block wreg;</script>
				</section>
				
				<section>
					<h3>5.1.7 不要涉及双边沿触发时序电路</h3>
				</section>
			</section>
			
			<section>
				<section>
					<h2>5.2 计数器</h2>
				</section>
				
				<section>
					<h3>5.2.1 四位二进制加法计数器</h3>
					<div class="flex">
						<script type="syntaxhighlighter" class="brush:vhdl;highlight:[3,9,10];"> 
ENTITY cnt4 IS
PORT(clk: IN bit; 
	   q: buffer integer range 15 downto 0 );
END ENTITY cnt4;

ARCHITECTURE bhv OF cnt4 IS
begin
	process (clk) begin
		if clk'event and clk='1' then
			q<=q+1;
		end if;
	end process;
end architecture bhv;		</script>
					<img src="images/cnt4.png" style="width:380px;height:200px;"/>
					</div>
					<img src="images/cnt4_wave.png"c/>
				</section>
				
				<section>
					<h3 style="font-size:40px;">5.2.2 更常用的四位二进制加法计数器描述</h3>
					<div class="flex">
						<script type="syntaxhighlighter" class="brush:vhdl;highlight:[2,3,6,7,15];">
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.STD_LOGIC_UNSIGNED.ALL;

ENTITY cnt4 IS
PORT(clk: IN std_logic; 
	   q: out std_logic_vector(3 downto 0));
END ENTITY cnt4;

ARCHITECTURE bhv OF cnt4 IS
signal q1: std_logic_vector(3 downto 0);
begin
	process (clk) begin
		if clk'event and clk='1' then
			q1<=q1+1;
		end if;
	end process;
	q <= q1;
end architecture bhv;		</script>
						<img src="images/cnt4_2.png" style="width:380px;height:200px;"/>
					</div>
					<img src="images/cnt4_2wave.png" style="width:800px;"/>
				</section>
				
				
				
				
				<section>
					<h3>5.2.3 带异步复位和同步加载的的十进制加法计数器</h3>

						<script type="syntaxhighlighter" class="brush:vhdl;highlight:[];">
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.STD_LOGIC_UNSIGNED.ALL;

ENTITY cnt10 IS
PORT(clk, rst, en, load: IN std_logic; 
	   data: in std_logic_vector(3 downto 0)); --预置数
	   dout: out std_logic_vector(3 downto 0)); --输出
	   cout: out std_logic); --进位
END ENTITY cnt10;

ARCHITECTURE bhv OF cnt10 IS
begin	</script>

				</section>
				
				<section>
					<h3>5.2.3 带异步复位和同步加载的的十进制加法计数器</h3>

						<script type="syntaxhighlighter" class="brush:vhdl;highlight:[];">
	process (clk,rst,en,load)
	variable q: std_logic_vector(3 downto 0);
	begin
		if rst='0' then 
			q:=(others->'0');
		elsif rising_edge(clk) then
			if en='1' then
				if (load = '0') then q:=data;
				else
					if q<9 then q:=q+1;
					else q:=(others=>'0');
					end if;
				end if;
			end if;
		end if;
		if q="1001" then cout <='1';
		else cout<='0';
		end if;
		dout<=q;
	end process;
end architecture bhv;		</script>

				</section>
				
				<section>
					<h4>5.2.3 带异步复位和同步加载的的十进制加法计数器-另一种描述</h4>
					<p>把时钟电路和纯组合电路进程分开，为了在进程间传递信号，不再使用 variable ，而是 signal 。</p>
						<script type="syntaxhighlighter" class="brush:vhdl;highlight:[13];">
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.STD_LOGIC_UNSIGNED.ALL;

ENTITY cnt10_2 IS
PORT(clk, rst, en, load: IN std_logic; 
	   data: in std_logic_vector(3 downto 0); --预置数
	   dout: out std_logic_vector(3 downto 0); --输出
	   cout: out std_logic); --进位
END ENTITY cnt10_2;

ARCHITECTURE behave OF cnt10_2 IS
signal q1: std_logic_vector(3 downto 0);
begin	</script>

				</section>
				
				<section>
						<script type="syntaxhighlighter" class="brush:vhdl;highlight:[1,19,21];">
	CLOCK: process (clk,rst,en,q1, load) begin
		if rst='0' then 
			q1 <=(others =>'0');
		elsif rising_edge(clk) then
			if en='1' then
				if (load = '0') then 
					q1<=data;
				else 
					if q1<9 then 
						q1<=q1+1; 
					else 
						q1<=(others=>'0');
					end if;
				end if;
			end if;
		end if;
	end process;
	
	dout <= q1;
	
	COM: process (q1) begin
		if q1="1001" then 
			cout <='1';
		else 
			cout<='0';
		end if;
	end process;
end architecture behave;		</script>

				</section>
				
				<section>
					<h3>5.2.3 带异步复位和同步加载的的十进制加法计数器</h3>
					<img src="images/cnt10.png" />
				</section>
				
				<section>
					<h3>5.2.3 带异步复位和同步加载的的十进制加法计数器</h3>
					<img src="images/cnt10_wave.png" style="width:1000px;"/>
				</section>
				
				<section>
					<h4>总结：variable 和 signal 的区别</h4>
					<ol>
						<li class="fragment fade-left">variable 只能用在process中，也只能定义在process 和 begin 之间；</li>
						<li class="fragment fade-left">signal 可以用在 architecture 内，以及 process中，但只能定义在 architecture 和 begin 之间；</li>
						<li class="fragment fade-left">variable 只能用在一个 process 中，而 signal 由于是定义在 architecture 中，所以可以在 architecture 内的所有 process 中被读取，但是只能在一个 process 中被赋值；</li>
						<li class="fragment fade-left">variable 的赋值是用 :=，而 signal 的赋值是用 &lt;= </li>
						<li class="fragment fade-left">variable 的赋值是立即的，也就是右边表达式中的信号一旦变化，马上就会被计算出结果并赋值给 variable, 但 signal 则要看电路是否是时序电路，如果不是，则马上赋值，如果是，则会等到下个时钟周期再赋值；</li>
						<li class="fragment fade-left">初学者尽量不要用 variable, 因为某些综合器对 variable 支持不好；</li>
					</ol>
				</section>
			</section>
		</div>
	</div>

	<script src="js/reveal.js-3.7.0/lib/js/head.min.js"></script>
	<script src="js/reveal.js-3.7.0/js/reveal.js"></script>
	
	<script>
		// More info https://github.com/hakimel/reveal.js#configuration
		Reveal.initialize({
			controls: true,
			progress: true,
			history: true,
			center: true,

			transition: 'slide', // none/fade/slide/convex/concave/zoom

			// More info https://github.com/hakimel/reveal.js#dependencies
			dependencies: [{
					src: 'js/reveal.js-3.7.0/lib/js/classList.js',
					condition: function () {
						return !document.body.classList;
					}
				},
				{
					src: 'js/reveal.js-3.7.0/plugin/markdown/marked.js',
					condition: function () {
						return !!document.querySelector('[data-markdown]');
					}
				},
				{
					src: 'js/reveal.js-3.7.0/plugin/markdown/markdown.js',
					condition: function () {
						return !!document.querySelector('[data-markdown]');
					}
				},
				{
					src: 'js/reveal.js-3.7.0/plugin/search/search.js',
					async: true
				},
				{
					src: 'js/reveal.js-3.7.0/plugin/zoom-js/zoom.js',
					async: true
				},
				{
					src: 'js/reveal.js-3.7.0/plugin/notes/notes.js',
					async: true
				}
			]
		});
	</script>

</body>

</html>